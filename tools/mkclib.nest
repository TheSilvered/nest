|#| 'stdio.nest' = io
|#| 'stdfs.nest' = fs
|#| 'stdsutil.nest' = su

#replace_file_str path s1 s2 [
    path 'r' @io.open = file
    file -1 @io.read s1 s2 @su.replace_substr = file_content
    file @io.close

    path 'w' @io.open = file
    file file_content @io.write
    file @io.close
]

{
    --    Headers          Source    --
    'compiler.h',       'compiler.c',
    'error_internal.h',
    'error.h',          'error.c',
    'function.h',       'function.c',
    'ggc.h',            'ggc.c'
    'hash.h',           'hash.c',
    'instructions.h',   'instructions.c',
    'interpreter.h',    'interpreter.c',
    'iter.h',           'iter.c',
    'lexer.h',          'lexer.c',
    'lib_import.h',     'lib_import.c',
    'llist.h',          'llist.c',
    'map.h',            'map.c',
    'nest_h',
    'nest_include.h',
    'nodes.h',          'nodes.c',
    'nst_types.h',
    'obj.h',            'obj.c',
    'obj_ops.h',        'obj_ops.c',
    'optimizer.h',      'optimizer.c',
    'parser.h',         'parser.c',
    'runtime_stack.h',  'runtime_stack.c',
    'sequence.h',       'sequence.c',
    'simple_types.h',   'simple_types.c',
    'str.h',            'str.c',
    'tokens.h',         'tokens.c',
    'var_table.h',      'var_table.c'
} = nest_source_files

#main [
    ($_args_ 3 !=) ($_args_ 4 !=) && ? [
        >>> 'USAGE: nest .\\mkclib.py (new <library_name>|update) <location>\n'
        => 1
    ]

    _args_.1 = operation
    ($_args_ 4 == ? _args_.2 : null) = project_name
    _args_.($_args_ 4 == ? 3 : 2) = location

    (operation 'new' !=) (operation 'update' !=) && ? [
        >>> ('The given operation ("'operation'") is not valid\n' ><)
        => 1
    ]

    !(location @fs.isdir) ? [
        >>> ('The given path ("'location'") doesn\'t exist\n' ><)
        => 2
    ]

    (location'\\nest_source' >< = srcdir) @fs.mkdir

    ... Iter :: nest_source_files := file_name [
        ('..\\nest\\'file_name ><) (srcdir'\\'file_name ><) fs.CPO.update @fs.copy
    ]

    operation 'update' == ? => 0

    project_name ' ' '_' @su.replace_substr = project_name_c

    !(project_name_c (su.LETTERS su.DIGITS '_' ><) @su.is_charset) ? [
        >>> ('The given name ("'project_name'") is not valid\n' ><)
        => 3
    ]

    project_name_c @su.to_upper = upper_project_name

    location'\\'project_name'.h' >< 'w' @io.open = header_file
    header_file ("#ifndef "upper_project_name"_H
#define "upper_project_name"_H

#include \"nest_source/nest_include.h\"

#if defined(_WIN32) || defined(WIN32)
#define EXPORT __declspec(dllexport)
#else
#define EXPORT
#endif

#ifdef __cplusplus
extern \"C\" {
#endif // !__cplusplus

EXPORT bool lib_init();
EXPORT Nst_FuncDeclr *get_func_ptrs();
EXPORT NST_INIT_LIB_OBJ_FUNC;
// EXPORT void free_lib();

// Here you can put your function signatures
// They must always be `NST_FUNC_SIGN(func_name);`
// replace func_name with your function's name

#ifdef __cplusplus
}
#endif // !__cplusplus

#endif // !"upper_project_name"_H" ><) @io.write
    header_file @io.close

    location'\\'project_name'.cpp' >< 'w' @io.open = source_file
    source_file ("#include \""project_name".h\"

#define FUNC_COUNT // Set this to the number of functions in your module

static Nst_FuncDeclr *func_list_;
static bool lib_init_ = false;

bool lib_init()
{
    if ( (func_list_ = nst_new_func_list(FUNC_COUNT)) == nullptr )
        return false;

    size_t idx = 0;

    // Set each function to an index in func_list_
    // func_list_[idx++] = NST_MAKE_FUNCDECLR(
    //     func_ptr, -> the function pointer
    //     1 -> the number of arguments the function takes
    // );
    //
    // The function will be accessed by nest throwgh the name of `func_ptr` but
    // if you wish to change it you can use:
    // func_list_[idx++] = NST_MAKE_NAMED_FUNCDECLR(func_ptr, 1, \"new_name\");
    // where 'new_name' is the name of the function

    lib_init_ = true;
    return true;
}

Nst_FuncDeclr *get_func_ptrs()
{
    return lib_init_ ? func_list_ : nullptr;
}

// Here you can put the implementations of your functions" ><) @io.write
    source_file @io.close

    -- remove precompiled header files
    location'\\pch.cpp' >< @fs.isfile ? location'\\pch.cpp' >< @fs.rmfile
    location'\\pch.h'   >< @fs.isfile ? location'\\pch.h'   >< @fs.rmfile

    -- change '#include "pch.h" to #include "framework.h"' since pch.h has
    -- just been removed
    (location'\\dllmain.cpp' >< @fs.isfile) \
    (location'\\framework.h' >< @fs.isfile) && ? [
        location'\\dllmain.cpp' >< 'pch' 'framework' @replace_file_str
    ]

    -- Turn off precompiled headers
    location'\\'project_name_c'.vcxproj' >< \
    '<PrecompiledHeader>Use' \
    '<PrecompiledHeader>NotUsing' @replace_file_str

    -- Set language to C++ 20
    location'\\'project_name_c'.vcxproj' >< \
    '</PrecompiledHeaderFile>\n    </ClCompile>' \
    "</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>" @replace_file_str

    -- Remove warnings for functions such as fopen, strcat etc.
    location'\\'project_name_c'.vcxproj' >< \
    '_WINDOWS;_USRDLL' \
    '_WINDOWS;_CRT_SECURE_NO_WARNINGS;_USRDLL' @replace_file_str

    '' = vcxproj_headers
    ... Iter :: nest_source_files := f [
        f.-1 'c' == ? ..
        -- The spaces pad the next line so the file still looks nice 
        vcxproj_headers '<ClInclude Include="nest_source\\' f '" />\n    ' >< = vcxproj_headers
    ]
    '<ClInclude Include="'project_name'.h" />' >< ><= vcxproj_headers

    '' = vcxproj_sources
    ... Iter :: nest_source_files := f [
        f.-1 'h' == ? ..
        vcxproj_sources '<ClCompile Include="nest_source\\' f '" />\n    ' >< = vcxproj_sources
    ]
    '<ClCompile Include="'project_name'.cpp" />' >< ><= vcxproj_sources

    -- Remove pch.h and pch.cpp from the listed files, add the source files
    location'\\'project_name_c'.vcxproj' >< \
        '<ClInclude Include="pch.h" />' vcxproj_headers @replace_file_str

    location'\\'project_name_c'.vcxproj' >< \
    "<ClCompile Include=\"pch.cpp\">
      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">Create</PrecompiledHeader>
      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">Create</PrecompiledHeader>
      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Create</PrecompiledHeader>
      <PrecompiledHeader Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Create</PrecompiledHeader>
    </ClCompile>" \
    vcxproj_sources @replace_file_str

    => 0
]

@main
